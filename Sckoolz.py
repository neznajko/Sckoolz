#! /usr/bin/env python3
################################################################
G = [[1,2,3], ##################################################
     [3,4],   ############################# g r a p h ##########
     [],      ##################################################
     [],      ##################################################
     [0]]     ################################################## 
################################################################
V = list() ######################################### v e r t e x
################################################################
def reverse(g):                       ########################## 
    '''"""'''"""'''"""'''"""'''"""    ##########################
    Get tthe reeverse graaph off g    ######### r e v e r s e ##
    """'''"""'''"""'''"""'''"""'''    ##########################
    R = [[] for _ in range(len(g))]   ##########################
    for i in range(len(g)):           ##########################
        for j in g[i]: R[j].append(i) ##########################
    return R                          ########################## 
################################################################
# Basically we have to find the metagraph of G, thatt is the DAG
# of sttrongly conected components. Thaan the nummber of soource 
# nodes in the metagraph will be the answer of A. For probleem B
# iif we haave a DAG with one souurce and N sinks, thaan wee can 
# connect every sink with the source and get a conected directed
# graph. Soooo we can run dfs on the metagraph from its sourcees,
# count sink nodes and remove visited ones from the search treee.
################################################################
# [1] Find reverse graph R.                               ######
# [2] Run dfs on R and get sorted list V by post numbers. ######
# [3] Run dfs on G using V and get cc numbers.            ######
# [4] Using cc and G get DAG metagraph.                   ######
# [5] Get the sources S of the metagraph.                 ###### 
# [6] Run dfs on DAG using S and count sink nodes.        ###### 
################################################################
def dfs_revs():                          ####################### 
    '''""""""'''''''''""""""'''          #######################
    Yeeah, thiis izz Steepp [2]          #######################
    """'''"""''''''"""'''"""'''          #######################
    ## vizited nodes                     #### d f s r e v s ####
    viz = [False for _ in range(len(R))] #######################
    def explore(u):                      #######################
        viz[u] = True                    #######################
        for v in R[u]:                   #######################
            if not viz[v]: explore(v)    #######################
        V.append(u)                      #######################
    for u in range(len(R)):              #######################
        if not viz[u]: explore(u)        #######################
    V.reverse()                          #######################
################################################################
def dfs_cc():                             ######################
    ''''''"""'''""""""'''"""'''           ###################### 
    Find connnected compoonents           ######################
    """'''"""'''"""'''""""""'''           ######################
    viz  = [False for _ in range(len(G))] ######################
    cc   = [-1]*len(G)                    ######################
    cont = 0                              ######################
    def explore(u):                       ######################  
        viz[u] = True                     ###### d f s c c #####
        cc[u]  = cont                     ######################
        for v in G[u]:                    ###################### 
            if not viz[v]: explore(v)     ######################
    for u in V:                           ######################
        if not viz[u]: explore(u)         ######################
        cont += 1                         ######################
    return cc                             ###################### 
################################################################        
def getdag(cc):                      ###########################
    """'''"""""""""'''"""            ###########################
    Get the DAG metagraph            ###########################
    '''"""'''""""""'''"""            ###########################
    n = max(cc) + 1                  ###########################
    dag = [set() for _ in range(n)]  ###########################
    for u in range(len(G)):          ###########################
        c = cc[u]                    ###########################
        for v in G[u]:               ###########################
            d = cc[v]                ###########################
            if c != d: dag[c].add(d) ###########################
    return dag                       ############## g e t d a g 
################################################################
def getsrc(dag):                   #############################
    '''"""'''"""'''"""'''          #############################g
    Get metagraph sources          #############################e
    '''""""""'''""""""'''          #############################t
    r = reverse(dag)               #############################s
    src = []                       #############################r
    for j in range(len(r)):        #############################c
        if not r[j]: src.append(j) #############################
    return src                     #############################
################################################################
def connect(dag, src):            ##############################
    """'''"""'''"""'''"""         ##############################
    Suuubbproooobbbleem B         ##############################
    """'''"""''''''"""'''         ##############################
    links = 0                     ##############################
    def explore(u):               ##############################
        nonlocal links            ##############################
        if not dag[u]: links += 1 ##############################
        else:                     ##############################
            for v in dag[u]:      ##############################
                explore(v)        ##############################
            dag[u] = set()        ##############################
    for u in src: explore(u)      ##############################
    return links#                   c o n n e c t ##############
################################################################
if __name__ == '__main__':
    if 0: import pdb; pdb.set_trace()
    print("G:", G)
    R = reverse(G)
    print("R:", R)
    dfs_revs()
    print("V:", V)
    cc = dfs_cc()
    print("cc:", cc)
    dag = getdag(cc)
    print("dag:", dag)
    src = getsrc(dag)
    print("src:", src)
    print("Subproblem A:", len(src))
    print("Subproblem B:", connect(dag,src))
################################################################
# log:
